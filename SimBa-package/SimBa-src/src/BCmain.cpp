#include "ANNSearchSampling.h"
#include "SimpleGraph.h"
#include "PointSet.h"
#include "SimplicialComplex.h"

#include <iostream>
#include <vector>
#include <cmath>
#include <sstream>
#include <cstring>
#include <fstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <limits>       // std::numeric_limits
#include <set>



#include <boost/program_options.hpp>

using namespace std;

//underlying one-skeleton for batch collapse
std::unordered_map<int, std::unordered_set<int>> oneSkel;
//maximal cliques involving all new edges for each vertex collapse
std::vector<std::vector<std::set<int>>> vecNewCliq;
extern int max_dimension;



////////////////
void ConstructRipsGraph(const float eps_val, const PointSet &inPts, SimpleGraph &outRipsGraph)
{
	//	Construct Rips graph on the input points
	float sqDistance = eps_val * eps_val;
	ANNSearch::BuildDistanceGraph_ann(outRipsGraph, inPts, sqDistance);
	return;
}
void ComputeEdgeWeights(const PointSet &inPts, SimpleGraph &outRipsGraph)
{
	float segLength = 0.f;
	LongVector tempDiff;
	//
	for (unsigned int i = 0; i < outRipsGraph.vecNode.size(); i++)
	{
		for (std::map<int, float>::iterator mIter = outRipsGraph.vecNode[i].edgeWeights.begin();
			mIter != outRipsGraph.vecNode[i].edgeWeights.end();
			mIter++)
		{
			tempDiff = (*inPts._PointSet)[i] - (*inPts._PointSet)[mIter->first];
			segLength = norm(tempDiff);
			mIter->second = segLength;
		}
	}
	return;
}
void DeltaSparseSampling_EuclideanDistance(const PointSet &inPts, const float delta_dist,
	std::map<int, int> &SubPointIndex,
	std::vector<int> &ColorMapping)
{
	//
	float sqDistance = 0.0;
	//
	// Perform the delta-sampling delta-sparse subsampling
	//
	sqDistance = delta_dist * delta_dist;
	ColorMapping.resize(inPts._PointSet->size());
	ANNSearch::Subsampling_EuclideanDistance(sqDistance,
		inPts,
		SubPointIndex,
		ColorMapping);

	return;
}
/////////////////

void ComputeBiColoredGraph(const float eps_sampling_dist, const float delta_dist, const bool graph_distance_flag, const PointSet &inPts,
	std::map<int, int> &SubPointIndex, SimpleGraph &biColoredGraph)
{
	//
	SimpleGraph RipsGraph;
	std::vector<int> ColorMapping;
	//
	ConstructRipsGraph(eps_sampling_dist, inPts, RipsGraph);
	//
	DeltaSparseSampling_EuclideanDistance(inPts, delta_dist, SubPointIndex, ColorMapping);
	//

	// construct the bi-colored graph from the org rips graph
	ANNSearch::SetColorMappingAndExtractColoredGraph(ColorMapping, RipsGraph, biColoredGraph);
	//
	//std::cout << "bic comp " << biColoredGraph.CheckComponents() << std::endl;
	biColoredGraph.color_number = (int)SubPointIndex.size();
	//RipsGraph.WriteBackToFile("test_rip.txt");
	return;
}
/***********************************************/
char * strLicense = "THIS SOFTWARE IS PROVIDED \"AS-IS\". THERE IS NO WARRANTY OF ANY KIND. "
"NEITHER THE AUTHORS NOR THE OHIO STATE UNIVERSITY WILL BE LIABLE FOR "
"ANY DAMAGES OF ANY KIND, EVEN IF ADVISED OF SUCH POSSIBILITY. \n"
"\n"
"This software was developed (and is copyrighted by) the Jyamiti group at "
"The Ohio State University. Please do not redistribute this software. "
"This program is for academic research use only. This software uses the "
"Boost library (www.boost.org) and Ann library "
"(www.cs.umd.edu/~mount/ANN/) which are covered under their own licenses.\n"
"\n"
"The Boost library's license "
"(which applies to the Boost library ONLY and NOT to this program itself) is "
"as follows:\n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"Boost Software License - Version 1.0 - August 17th, 2003\n"
"\n"
"Permission is hereby granted, free of charge, to any person or organization "
"obtaining a copy of the software and accompanying documentation covered by "
"this license (the \"Software\") to use, reproduce, display, distribute, "
"execute, and transmit the Software, and to prepare derivative works of the "
"Software, and to permit third-parties to whom the Software is furnished to "
"do so, all subject to the following: \n"
"\n"
"The copyright notices in the Software and this entire statement, including "
"the above license grant, this restriction and the following disclaimer, "
"must be included in all copies of the Software, in whole or in part, and "
"all derivative works of the Software, unless such copies or derivative "
"works are solely in the form of machine-executable object code generated by "
"a source language processor. \n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR "
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, "
"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT "
"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE "
"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, "
"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER "
"DEALINGS IN THE SOFTWARE. \n"
"---------------------------------------------------------------------------\n"
"\n"
"ANN library's license "
"(which applies to the ANN library ONLY and NOT to this program itself) is "
"as follows: \n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"The ANN Library (all versions) is provided under the terms and "
"conditions of the GNU Lesser General Public Library, which is stated "
"below.  It can also be found at: \n"
"\n"
"   http:////www.gnu.org/copyleft/lesser.html \n"
"---------------------------------------------------------------------------\n";
/**********************************************************************/
bool ParseCommand(int argc, char** argv,
	std::string &InputFile,
	std::string &OutputFile,
	int &max_dimension,
	float &scale_increase)
{
	try
	{
		/* Define the program options description
		*/
		namespace po = boost::program_options;
		po::options_description desc("SimBa Usage");
		desc.add_options()
			(",h", "Help information;")
			(",l", "License information;")
			(",i", po::value<std::string>(&InputFile)->required(), "Input file name;")
			(",o", po::value<std::string>(&OutputFile)->default_value("persistence.txt"), "Output file name prefix (default \"persistence.txt\");")
			(",c", po::value<float>(&scale_increase)->default_value(1.1), "The parameter of scale increase between two batches (default 1.1);")
			("dim", po::value<int>(&max_dimension)->default_value(2), "The maximum dimension of simplices in output complexes (default 2);");
		// Parser map
		po::variables_map vm;
		try
		{
			po::store(po::parse_command_line(argc, argv, desc), vm);

			//
			if (vm.count("-h"))
			{
				std::cout << desc << std::endl;
				exit(0);
			}
			//
			if (vm.count("-l"))
			{
				std::cout << strLicense << std::endl;
				exit(0);
			}
			//
			po::notify(vm);
		}
		catch (boost::program_options::required_option& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
		catch (boost::program_options::error& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
	}
	catch (std::exception& e)
	{
		std::cerr << "Unhandled Exception reached the top of main: "
			<< e.what() << ", application will now exit" << std::endl;
		return false;

	}
	return true;
}
double computeDelta(double alpha, double eps, int k)
{
	double multiProduct = 1;
	for (int i = 0; i < k; ++i)
	{
		multiProduct = multiProduct * (1 + eps);
	}
	multiProduct = multiProduct / (1 + eps);
	return alpha * eps * eps * multiProduct / 2;
}

//modified BronKerbosch algorithm to list all maximal clique and subcliques, visit each only once
void BronKerbosch(std::set<int>& R, std::set<int>& P)
{
	if (R.size() > max_dimension + 2)
		return;
	vecNewCliq[R.size() - 2].push_back(R);
	if (P.empty())
		return;
	std::set<int>::iterator it = P.begin();
	std::set<int>::iterator itNext;
	for (; it != P.end(); it = itNext)
	{
		itNext = it;
		++itNext;
		int v = *it;
		std::unordered_set<int>& nv = oneSkel[v];
		std::set<int> R1(R);
		std::set<int> P1;
		R1.insert(v);
		std::unordered_set<int>::iterator iter = nv.begin();
		for (; iter != nv.end(); ++iter)
		{
			if (*iter > v && P.find(*iter) != P.end())
				P1.insert(*iter);
		}
		BronKerbosch(R1, P1);
		P.erase(it);
	}
}

bool MyCompare(const std::pair<int, float>& p1, const std::pair<int, float>& p2)
{
	return (p1.second < p2.second);
}

bool barcodeCompare(const pair<int, int>& a, const pair<int, int>& b)
{
	//death time order
	if (a.second != -1 && b.second != -1)
		return (a.second < b.second);
	if (a.second == -1 && b.second != -1)
		return false;
	if (a.second != -1 && b.second == -1)
		return true;
	return a.first < b.first;

	////random order
	//srand(time(NULL));
	//int m = rand();
	//int n = rand();
	//return m < n;
}

/*********************/
int main(int argc, char **argv)
{
	//
	std::clock_t start = std::clock();

	std::string InputFileName;
	std::string OutputFileName;
	float scaleIncrease;
	ofstream ofsTime("Timing.txt");
	bool bDeathTimeOrder = true;
	//
	if (ParseCommand(argc, argv, InputFileName, OutputFileName, max_dimension, scaleIncrease))
	{
		{
			SimplicialTree<bool> domain_complex;
			PointSet pts;
			pts.ReadPointsFromFile(InputFileName.c_str());
			//initialize vecNewCliq to have enough size to hold simplicies up to max_dimension
			vecNewCliq.resize(max_dimension + 1);
			////
			std::string outfile_name(OutputFileName);
			bool bOriginalOrder = true;
			bool bSetDistance = true;
			bool bAddCliques = true;
			bool bAddExtraEdges = true;
			bool bMinNNDis = true;
			int iThresNum = pts._size / 50;
			bool bAnnKDtree = true;
			double annTolerance = 0;
			filtration_step = 0;
			fThreshold = 0;
			vecFiltrationScale.push_back(0);
			std::vector<int> vecSimplex;
			//initialize input domain complex
			//insert only vertices
			for (unsigned int i = 0; i < pts._size; ++i)
			{
				vecSimplex.clear();
				vecSimplex.push_back(i);
				domain_complex.ElementaryInsersion(vecSimplex);
			}
			complexSizes.push_back(domain_complex.ComplexSize());
			accumulativeSizes.push_back(domain_complex.accumulativeSimplexSize);
			std::cout << "-----intial complex has been processed-------" << endl;
			//compute delta net Q
			PointSet ptsQ(pts);
			//used in random sampling
			std::vector<std::vector<float>> vecSetDistance;
			//store the new indicies in the set distance array for each remaining point: <original index, array index>
			std::unordered_map<int, int> mapSetIndicies;
			bool bSetDistanceInitialized = false;
			//store which set this point currently belongs to
			std::vector<int> vecCurrentSet(ptsQ._size);
			for (int i = 0; i < vecCurrentSet.size(); ++i)
				vecCurrentSet[i] = i;
			//store the all the points in each remaining set (all points should have been
			//	collapsed to the current set representative point)
			std::unordered_map<int, vector<int>> mapSetElements;
			//initializaiton
			for (int i = 0; i < ptsQ._size; ++i)
				mapSetElements[i].push_back(i);
			std::unordered_set<int> setRemainPoints;
			int collapseSize = 0;
			int j, pj, i, pi;
			float lambda_max, lambda_j, lambda_i;
			//initialize representative set
			for (int i = 0; i < ptsQ._size; ++i)
				setRemainPoints.insert(i);
			//initialize annsearch kd_tree on ptsQ
			int nPts = (int)ptsQ._size;
			int dim = ptsQ._dimension;
			ANNdist sqRadius;
			ANNpoint queryPt;
			ANNidxArray nnIdx = NULL;
			ANNdistArray dists = NULL;
			queryPt = annAllocPt(dim);
			nnIdx = new ANNidx[nPts];
			dists = new ANNdist[nPts];
			ANNpointArray dataPts;
			dataPts = annAllocPts(nPts, dim);
			// adding vertices
			for (int i = 0; i < nPts; i++)
			for (int j = 0; j < dim; j++)
				dataPts[i][j] = (*ptsQ._PointSet)[i][j];
			///////////////////
			ANNkd_tree* kdTree;
			kdTree = new ANNkd_tree(dataPts, nPts, dim);
			cout << "-------annsearch kd-tree has been initialized-------" << endl;
			//find nearest pairwise point distance in random sampling
			std::vector<pair<int, float>> vecSortedPts;
			double minDis = std::numeric_limits<float>::max();
			double avgDis = 0;
			for (int i = 0; i < ptsQ._size; ++i)
			{
				for (int d = 0; d < dim; ++d)
					queryPt[d] = (*ptsQ._PointSet)[i][d];
				int iN;
				iN = kdTree->annkFRSearch(
					queryPt,
					ZERO * ZERO,
					0, // to get the number of points within the radius
					nnIdx,
					dists,
					annTolerance);
				kdTree->annkSearch(					// approx k near neighbor search
					queryPt,				// query point
					iN + 1,				// number of near neighbors to return
					nnIdx,			// nearest neighbor array (modified)
					dists,				// dist to near neighbors (modified)
					annTolerance);		// error bound
				double nnDis = sqrt(dists[iN]);
				avgDis += nnDis / ptsQ._size;
				vecSortedPts.push_back(std::make_pair(i, nnDis));
				if (nnDis < minDis)
					minDis = nnDis;
			}
			if (bMinNNDis)
				lambda_j = minDis;
			else
				lambda_j = avgDis;
			//sort points according to their nearest neighbor distances
			std::stable_sort(vecSortedPts.begin(), vecSortedPts.end(), MyCompare);
			PointSet ptsSub;
			ptsSub._dimension = ptsQ._dimension;
			ptsSub._size = 0;
			ptsSub._PointSet = new vector<LongVector>;
			cout << "-------minimum pairwise distance has been computed-------" << endl;
			cout << "min nearest neighbor distance: " << lambda_j << endl;
			ofsTime << "min nearest neighbor distance: " << lambda_j << endl;
			cout << "scale : # vertices : # simplicies" << endl;
			ofsTime << "scale : # vertices : # simplicies" << endl;
			std::vector<int> vecBackingIndexPkP0;
			//perform batch collapse here
			std::vector<std::pair<int, float>> vecPkNNDis;
			//any point whose index is >= iCut will be kept itself in the subsampling, 
			//hence there is no need to involve it in the delta subsampling process for saving time
			int iCut = 0;
			double dNextScale;
			while (true)
			{
				filtration_step += 1;
				vecPkNNDis.clear();
				//store new edges due to collapse in this batch
				std::unordered_map<int, std::unordered_set<int>> mapColEdges;
				dNextScale = lambda_j * scaleIncrease;
				PointSet curPS;
				//shallow copy
				curPS = ptsSub;
				j = curPS._size + (ptsQ._size - iCut);
				if (iCut < ptsQ._size)
				{
					int h = iCut;
					while (h < ptsQ._size && vecSortedPts[h].second <= dNextScale)
					{
						(*curPS._PointSet).push_back((*ptsQ._PointSet)[vecSortedPts[h].first]);
						vecBackingIndexPkP0.push_back(vecSortedPts[h].first);
						curPS._size += 1;
						++h;
					}
					iCut = h;
				}
				std::map<int, int> subsampleIndices;
				std::vector<int> colorMapping;
				//may include graph distance version later
				DeltaSparseSampling_EuclideanDistance(curPS, dNextScale, subsampleIndices, colorMapping);
				//update next ptsSub
				ptsSub._PointSet = NULL;
				curPS.CreateSubset(ptsSub, subsampleIndices);
				std::vector<std::vector<int>> vecSets(subsampleIndices.size());
				std::vector<int> vecBackingIndexPkplus1P0(subsampleIndices.size());
				for (int i = 0; i < colorMapping.size(); ++i)
					vecSets[colorMapping[i]].push_back(i);
				std::map<int, int>::iterator it = subsampleIndices.begin();
				for (; it != subsampleIndices.end(); ++it)
				{
					for (int i = 0; i < vecSets[it->second].size(); ++i)
					{
						//collapse y to x 
						//x and y are original point indicies
						int x = vecBackingIndexPkP0[it->first];
						int y = vecBackingIndexPkP0[vecSets[it->second][i]];
						if (x != y)
						{
							double dist = (*(ptsQ._PointSet))[x].euclideanDistanceTo((*(ptsQ._PointSet))[y]);
							vecPkNNDis.push_back(std::make_pair(y, dist));
							vecCurrentSet[y] = x;
						}
					}
					vecBackingIndexPkplus1P0[it->second] = vecBackingIndexPkP0[it->first];
				}
				//update vecBackingIndexPkP0
				vecBackingIndexPkP0 = vecBackingIndexPkplus1P0;
				if (subsampleIndices.size() == 1 && iCut >= ptsQ._size)
					break;
				//sort pk according to vecPkNNDis
				if (!bOriginalOrder)
					std::stable_sort(vecPkNNDis.begin(), vecPkNNDis.end(), MyCompare);
				//store new edges due to collapse for each collapsed vertex
				for (int i = 0; i < vecPkNNDis.size(); ++i)
				{
					int pk = vecPkNNDis[i].first;
					//nearest neighbor of pk in Pi
					int pnn = vecCurrentSet[pk];
					std::unordered_set<int> pkNB = oneSkel[pk];
					std::unordered_set<int> pnnNB = oneSkel[pnn];
					//elementary collapse
					domain_complex.ElementaryCollapse(pk, pnn);
					//delete pk from underlying one-skeleton
					for (std::unordered_set<int>::iterator it = pkNB.begin(); it != pkNB.end(); ++it)
					{
						int pn = *it;
						oneSkel[pn].erase(pk);
					}
					oneSkel.erase(pk);
					//add edges due to collapse
					for (std::unordered_set<int>::iterator it = pkNB.begin(); it != pkNB.end(); ++it)
					{
						int pp = *it;
						if (pp != pnn && pnnNB.find(pp) == pnnNB.end())	//found a new edge (pp, pnn) due to collapse
						{
							//add new edge to mapColEdges
							mapColEdges[pnn].insert(pp);
							mapColEdges[pp].insert(pnn);
						}
					}
					//update set distance after under iThresNum
					if (bSetDistanceInitialized && j <= iThresNum && bAnnKDtree)
					{
						for (std::unordered_set<int>::iterator it = setRemainPoints.begin(); it != setRemainPoints.end(); ++it)
						{
							int pp = *it;
							if (pp != pnn && pp != pk)
							{
								//set distance from current rep to pk
								int pkInd = mapSetIndicies[pk];
								int ppInd = mapSetIndicies[pp];
								int pnnInd = mapSetIndicies[pnn];
								float fDisPk = vecSetDistance[pkInd][ppInd];
								if (bSetDistance)
								{
									//update set distances
									if (fDisPk < vecSetDistance[pnnInd][ppInd])
									{
										//update both [pnn][*it] and [*it][pnn]
										vecSetDistance[pnnInd][ppInd] = fDisPk;
										vecSetDistance[ppInd][pnnInd] = fDisPk;
									}
								}
							}
						}
					}
					//merge set pk into set pnn and delete set pk
					//use reference to decrease map's member-access times
					std::vector<int>& vecPnn = mapSetElements[pnn];
					std::vector<int>& vecPk = mapSetElements[pk];
					vecPnn.reserve(vecPnn.size() + vecPk.size());
					vecPnn.insert(vecPnn.end(), vecPk.begin(), vecPk.end());
					mapSetElements.erase(pk);
					//delete pk from setRemainPoints
					setRemainPoints.erase(pk);
				}
				//add edges (due to both collapse and scale increase) globally
				std::unordered_set<int>::iterator itSet;
				for (itSet = setRemainPoints.begin(); itSet != setRemainPoints.end(); ++itSet)
				{
					//new edges due to both collapse and extra edges
					std::vector<int> vecNewEdges;	//these new edges must incidient to pnn, so only need to store the other end vertex
					int pnn = *itSet;		//different from the preivous pnn
					std::unordered_set<int> setNewEdges;
					if (mapColEdges.find(pnn) != mapColEdges.end())
					{
						std::unordered_set<int>::iterator iter = mapColEdges[pnn].begin();
						for (; iter != mapColEdges[pnn].end(); ++iter)
							setNewEdges.insert(vecCurrentSet[*iter]);
					}
					//at first, use ANN heuristics to search candidate sets to add edges to
					//don't need to keep record of pairwise set distances
					if (subsampleIndices.size() + (ptsQ._size - iCut)> iThresNum && bAnnKDtree)
					{
						std::vector<int>& vecPnn = mapSetElements[pnn];
						for (int l = 0; l < vecPnn.size(); ++l)
						{
							int NeighborCounter;
							int iN;
							int cur_pt_idx = vecPnn[l];
							// set up the query point as this point
							for (int d = 0; d < dim; ++d)
								queryPt[d] = (*ptsQ._PointSet)[cur_pt_idx][d];
							// get the number of points inside the fixed radius
							iN = kdTree->annkFRSearch(
								queryPt,
								dNextScale * dNextScale,
								0, // to get the number of points within the radius
								nnIdx,
								dists,
								annTolerance);
							NeighborCounter = kdTree->annkFRSearch(
								queryPt,
								dNextScale * dNextScale,
								iN,
								nnIdx,
								dists,
								annTolerance);
							// record edges
							if (NeighborCounter > iN)
							{
								std::cout << "k in ANN is too small" << std::endl;
								exit(0);
							}
							if (NeighborCounter > 0)
							{
								//assume self point is contained in results
								//namely, nnIdx[0] == cur_pt_idx
								for (int j = 1; j < NeighborCounter; j++)
								{
									std::vector<int> vecPath;
									int iSet = nnIdx[j];
									//find root
									while (vecCurrentSet[iSet] != iSet)
									{
										int parent = vecCurrentSet[iSet];
										if (parent != vecCurrentSet[parent])
											vecPath.push_back(iSet);
										iSet = parent;
									}
									//path compression
									for (int i = 0; i < vecPath.size(); ++i)
										vecCurrentSet[vecPath[i]] = iSet;
									if (iSet != pnn)
										setNewEdges.insert(iSet);
								}
							}
						}
						std::unordered_set<int> pnnNB = oneSkel[pnn];
						std::unordered_set<int>::iterator it = setNewEdges.begin();
						for (; it != setNewEdges.end(); ++it)
						{
							int iNewEdgeP = *it;
							if (iNewEdgeP != pnn && pnnNB.find(iNewEdgeP) == pnnNB.end())
							{
								int a = pnn < iNewEdgeP ? pnn : iNewEdgeP;
								int b = pnn > iNewEdgeP ? pnn : iNewEdgeP;
								//elementary insertion
								vecSimplex.clear();
								vecSimplex.push_back(a);
								vecSimplex.push_back(b);
								domain_complex.ElementaryInsersion(vecSimplex);
								//update one-skeleton
								oneSkel[iNewEdgeP].insert(pnn);
								oneSkel[pnn].insert(iNewEdgeP);
								//add new edge to vecNewEdges
								vecNewEdges.push_back(iNewEdgeP);
							}
						}
					}
					//after the remaining points are less than iThresNum, use set distance to proceed
					else
					{
						//initialize set distance
						if (!bSetDistanceInitialized)
						{
							cout << "initializing set distance..." << endl;
							ofsTime << "initializing set distance..." << endl;
							bSetDistanceInitialized = true;
							int arrayIndex = 0;
							vecSetDistance.resize(setRemainPoints.size());
							for (int i = 0; i < vecSetDistance.size(); ++i)
								vecSetDistance[i].resize(setRemainPoints.size());
							//use ANN to compute set distances
							//initialize n ANN kd-tree (n sets left)
							std::vector<ANNkd_tree*> vecANNtrees;
							for (std::unordered_set<int>::iterator it = setRemainPoints.begin(); it != setRemainPoints.end(); ++it)
								//initialize set indices in both set distance array and ANNtrees array
								mapSetIndicies[*it] = arrayIndex++;
							for (std::unordered_set<int>::iterator it = setRemainPoints.begin(); it != setRemainPoints.end(); ++it)
							{
								//initialize annsearch kd_tree on ptsQ
								std::vector<int> &vecSet = mapSetElements[*it];
								int nPts = vecSet.size();
								ANNpointArray dataPts;
								dataPts = annAllocPts(nPts, dim);
								// adding vertices
								for (int i = 0; i < nPts; i++)
								{
									for (int j = 0; j < dim; j++)
										dataPts[i][j] = (*ptsQ._PointSet)[vecSet[i]][j];
								}
								///////////////////
								vecANNtrees.push_back(new ANNkd_tree(dataPts, nPts, dim));
								//annDeallocPts(dataPts);
							}
							//compute set distance here
							for (std::unordered_set<int>::iterator it1 = setRemainPoints.begin(); it1 != setRemainPoints.end(); ++it1)
							{
								int row = mapSetIndicies[*it1];
								std::unordered_set<int>::iterator it2 = it1;
								for (; it2 != setRemainPoints.end(); ++it2)
								{
									float fMinDis = std::numeric_limits<float>::max();
									int col = mapSetIndicies[*it2];
									if (row == col)
										vecSetDistance[row][col] = 0;
									else
									{
										std::vector<int> vecSet = mapSetElements[*it1];
										for (int i = 0; i < vecSet.size(); ++i)
										{
											// set up the query point as this point
											for (int d = 0; d < dim; ++d)
												queryPt[d] = (*ptsQ._PointSet)[vecSet[i]][d];
											//this ANNtree doesn't contain the query point, so return 1 neighbor is enough
											vecANNtrees[col]->annkSearch(					// approx k near neighbor search
												queryPt,				// query point
												1,				// number of near neighbors to return
												nnIdx,			// nearest neighbor array (modified)
												dists,				// dist to near neighbors (modified)
												annTolerance);		// error bound
											if (dists[0] < fMinDis)
												fMinDis = dists[0];
										}
										//
										vecSetDistance[row][col] = vecSetDistance[col][row] = sqrt(fMinDis);
									}
								}
							}
							//release vecANNtrees memory
							for (int i = 0; i < vecANNtrees.size(); ++i)
								delete vecANNtrees[i];
						}
						//add extra edges
						for (std::unordered_set<int>::iterator it = setRemainPoints.begin(); it != setRemainPoints.end(); ++it)
						{
							int pp = *it;
							if (pp != pnn)
							{
								//set distance from current rep to pk
								int ppInd = mapSetIndicies[pp];
								int pnnInd = mapSetIndicies[pnn];
								float fDisPk = vecSetDistance[pnnInd][ppInd];
								if (fDisPk <= dNextScale)
									setNewEdges.insert(pp);
							}
						}
						std::unordered_set<int> pnnNB = oneSkel[pnn];
						std::unordered_set<int>::iterator it = setNewEdges.begin();
						for (; it != setNewEdges.end(); ++it)
						{
							int iNewEdgeP = *it;
							if (iNewEdgeP != pnn && pnnNB.find(iNewEdgeP) == pnnNB.end())
							{
								int a = pnn < iNewEdgeP ? pnn : iNewEdgeP;
								int b = pnn > iNewEdgeP ? pnn : iNewEdgeP;
								//elementary insertion
								vecSimplex.clear();
								vecSimplex.push_back(a);
								vecSimplex.push_back(b);
								domain_complex.ElementaryInsersion(vecSimplex);
								//update one-skeleton
								oneSkel[iNewEdgeP].insert(pnn);
								oneSkel[pnn].insert(iNewEdgeP);
								//add new edge to vecNewEdges
								vecNewEdges.push_back(iNewEdgeP);
							}
						}
					}
					//clear vecMaximalCliq;
					for (int d = 0; d < max_dimension + 1; ++d)
						vecNewCliq[d].clear();
					//add cliques here
					//insert new cliques involving new edges vecNewEdges incident to pnn
					std::set<int> R;
					std::unordered_set<int> P(oneSkel[pnn]);
					R.insert(pnn);
					for (int i = 0; i < vecNewEdges.size(); ++i)
					{
						std::set<int> R1(R);
						std::set<int> P1;
						int v = vecNewEdges[i];
						std::unordered_set<int>& nv = oneSkel[v];
						R1.insert(v);
						std::unordered_set<int>::iterator iter = nv.begin();
						for (; iter != nv.end(); ++iter)
						{
							if (P.find(*iter) != P.end())
								P1.insert(*iter);
						}
						BronKerbosch(R1, P1);
						P.erase(v);
					}
					//insert all new cliques
					//vecNewCliq[0] stores all the new edges, vecNewCliq[1] stores all the new triangles, and so on...
					for (int i = 0; i < vecNewCliq.size(); ++i)
					{
						//all new edges are already inserted, no need to insert again
						if (i == 0)
							continue;
						//no higher dimensional cliques
						if (vecNewCliq[i].size() == 0)
							break;
						//insert all new cliques in vecNewCliq[i]
						for (int j = 0; j < vecNewCliq[i].size(); ++j)
						{
							vecSimplex.clear();
							std::set<int>::iterator iter = vecNewCliq[i][j].begin();
							for (; iter != vecNewCliq[i][j].end(); ++iter)
								vecSimplex.push_back(*iter);
							domain_complex.ElementaryInsersion(vecSimplex);
						}
					}
				}
				lambda_j = dNextScale;
				vecFiltrationScale.push_back(lambda_j / 2);
				cout << lambda_j / 2 << " : " << setRemainPoints.size() << " : " << domain_complex.ComplexSize() << endl;
				ofsTime << lambda_j / 2 << " : " << setRemainPoints.size() << " : " << domain_complex.ComplexSize() << endl;
				collapseSize += 1;
				complexSizes.push_back(domain_complex.ComplexSize());
				accumulativeSizes.push_back(domain_complex.accumulativeSimplexSize);
			}
			//release memory and close ann
			if (bAnnKDtree)
			{
				bAnnKDtree = false;
				delete[] nnIdx;
				delete[] dists;
				delete kdTree;
				if (dataPts)
					annDeallocPts(dataPts);
				if (queryPt)
					annDeallocPt(queryPt);
				annClose();
			}
			lambda_j = dNextScale;
			cout << "max scale: " << lambda_j / 2 << endl;
			ofsTime << "max scale: " << lambda_j / 2 << endl;
			filtration_step += 1;
			//sorting the collapse order
			if (!bOriginalOrder)
				std::stable_sort(vecPkNNDis.begin(), vecPkNNDis.end(), MyCompare);
			for (int i = 0; i < vecPkNNDis.size(); ++i)
			{
				int pk = vecPkNNDis[i].first;
				domain_complex.ElementaryCollapse(pk, vecCurrentSet[pk]);
			}
			vecFiltrationScale.push_back(lambda_j / 2);
			collapseSize += 1;
			complexSizes.push_back(domain_complex.ComplexSize());
			accumulativeSizes.push_back(domain_complex.accumulativeSimplexSize);
			std::cout << "# of filtration: " << collapseSize << endl;
			ofsTime << "# of filtration: " << collapseSize << endl;
		}
	}
	//output dgm file for barcode display
	ofstream ofs_dgm(OutputFileName);
	for (int i = 0; i < persistences.size(); ++i)
	{
		std::vector<std::pair<int, int>> vecBarcodes;
		for (std::unordered_map<int, pair<int, int>>::iterator it = persistences[i].begin(); it != persistences[i].end(); ++it)
		{
			if (bDeathTimeOrder)
				vecBarcodes.push_back(std::make_pair((it->second).first, (it->second).second));
			else
			{
				ofs_dgm << i << " " << vecFiltrationScale[(it->second).first] << " ";
				if ((it->second).second == -1)
					ofs_dgm << "inf" << endl;
				else
					ofs_dgm << vecFiltrationScale[(it->second).second] << endl;
			}
		}
		if (bDeathTimeOrder)
		{
			std::stable_sort(vecBarcodes.begin(), vecBarcodes.end(), barcodeCompare);
			for (int k = 0; k < vecBarcodes.size(); ++k)
			{
				ofs_dgm << i << " " << vecFiltrationScale[vecBarcodes[k].first] << " ";
				if (vecBarcodes[k].second == -1)
					ofs_dgm << "inf" << endl;
				else
					ofs_dgm << vecFiltrationScale[vecBarcodes[k].second] << endl;
			}
		}
	}
	ofs_dgm.close();
	ofs_dgm.clear();

	int maxCS = 0;
	for (int i = 0; i < complexSizes.size(); ++i)
	{
		if (complexSizes[i] > maxCS)
			maxCS = complexSizes[i];
	}

	cout << "Total time: " << (std::clock() - start) / (double)CLOCKS_PER_SEC << "s" << endl;
	ofsTime << "Total time: " << (std::clock() - start) / (double)CLOCKS_PER_SEC << "s" << endl;
	ofsTime << "Max Complex Size: " << maxCS << endl;
	cout << "Max Complex Size: " << maxCS << endl;
	ofsTime << "Max Accumulative Complex Size: " << accumulativeSizes.back() << endl;
	cout << "Max Accumulative Complex Size: " << accumulativeSizes.back() << endl;
	ofsTime << "Max Scale: " << vecFiltrationScale.back() << endl;
	ofsTime.close();
	ofsTime.clear();
	return 0;
}
